import random
from typing import List
from itertools import accumulate
from GraphDataStructure import Graph

"""
CONSTANTS
"""
# Pheromone relative importance
ALPHA = 1
# Relative importance of heuristic factor
BETA = 5
# Pheromone evaporation coefficient (1 - RHO indicates the persistence factor).
RHO = 0.95


def performAntTSP(graph: Graph, pheromoneMatrix: List[List[float]],
                  path: List[int], currentNode: int, numOfNodes: int) -> int:
    """
    Determines the step each ant will make through the graph
    :param graph: Uses our custom Graph class which contains the adjacency matrix
    :param pheromoneMatrix: Matrix containing the pheromone values for each edge on our graph
    :param path: The current path that the ant has traversed
    :param currentNode: The node that the ant is currently on
    :param numOfNodes: The number of nodes in our graph
    :return: The node which the ant should visit next according to our algorithm
    """
    heuristicMatrix = [[round(1 / graph.adjMatrix[i][j], 5) if i != j and j not in path else 0
                        for j in range(numOfNodes)] for i in range(numOfNodes)]

    cumulativeProbabilities = determineProbabilities(pheromoneMatrix[currentNode], heuristicMatrix[currentNode])
    return determineStep(cumulativeProbabilities)


def determineProbabilities(pheromoneRow: List[float], heuristicRow: List[float]) -> List[float]:
    """
    Determines the probability of traversing each edge from a given node
    :param pheromoneRow: The pheromone distribution of each path from a given node
    :param heuristicRow: Used to make shorter paths more likely to be taken
    The weighting of our pheromone and heuristic matrices are determined by the defined ALPHA/BETA constants
    :return: The cumulative probability of visiting each node from our current node
    """
    numerator = [pheromoneRow[i] ** ALPHA * heuristicRow[i] ** BETA for i in range(len(heuristicRow))]
    denominator = sum(numerator)
    probabilities = [num / denominator for num in numerator]
    return list(accumulate(probabilities))


def determineStep(probabilities: List[float]) -> int:
    """
    Generates a random number between [0, 1] to determine which edge the ant will traverse
    :param probabilities: List of cumulative probabilities ranging from [0, 1]
    :return: The edge which should be taken by the ant
    """
    randomStep = random.random()
    for probability in probabilities:
        if randomStep <= probability:
            return probabilities.index(probability)


def evaporatePheromones(pheromoneMatrix: List[List[float]], numberOfNodes: int) -> List[List[float]]:
    """
    Evaporates pheromones off each edge using our defined constant RHO
    :param pheromoneMatrix: The pheromone distribution of each edge of our graph
    :param numberOfNodes: The number of nodes in our graph
    :return: The pheromone distribution of each edge after evaporation
    """
    return [[(1 - RHO) * pheromoneMatrix[i][j] for j in range(numberOfNodes)] for i in range(numberOfNodes)]


def updatePheromones(pheromoneMatrix: List[List[float]], path: List[int], pathLength: int) -> List[List[float]]:
    """
    Once a path has been traversed, the ant will deposit pheromones on every edge taken
    :param pheromoneMatrix: The pheromone distribution of each edge of our graph
    :param path: The path taken by the ant
    :param pathLength: The length of the path taken by the ant
    :return: The pheromone distribution of each edge after depositing pheromones
    """
    deposit = 1 / pathLength
    for i in range(len(path) - 1):
        pheromoneMatrix[path[i]][path[i + 1]] += deposit
    return pheromoneMatrix


def runAntColonyTSP(graph: Graph, startingNode: int = 0, numberOfIterations: int = 100):
    """
    Runs the Ant Colony Optimization TSP algorithm on our graph
    :param graph: Uses our custom Graph class which contains the adjacency matrix
    :param startingNode: Our starting (and ending) node
    :param numberOfIterations: The number of iterations of our algorithm we will perform
    :return: A tuple containing the path generated by the algorithm, and the length of this path
    """
    numOfNodes = graph.size
    pheromoneMatrix = [[1 for _ in range(numOfNodes)] for _ in range(numOfNodes)]
    path = []
    pathLength = 0

    # According to M. Dorigo, the optimal number of ants is 2n/5 where n is number of nodes
    numberOfAnts = max((numOfNodes // 5) * 2, 1)

    for _ in range(numberOfIterations):
        pheromoneMatrix = evaporatePheromones(pheromoneMatrix, numOfNodes)

        for _ in range(numberOfAnts):
            pathLength = 0
            path = [startingNode]
            currentNode = startingNode

            # Generates a Hamiltonian Cycle for the current ant.
            while len(path) != numOfNodes:
                visitingNode = performAntTSP(graph, pheromoneMatrix, path, currentNode, numOfNodes)
                path.append(visitingNode)
                pathLength += graph.adjMatrix[currentNode][visitingNode]
                currentNode = visitingNode

            path.append(startingNode)
            pathLength += graph.adjMatrix[currentNode][startingNode]
            # Deposits pheromones onto the path that the ant took.
            pheromoneMatrix = updatePheromones(pheromoneMatrix, path, pathLength)

    return path, pathLength
