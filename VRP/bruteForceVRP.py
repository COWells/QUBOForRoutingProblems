import itertools
import math
from typing import List, Tuple
from GraphDataStructure import Graph

distances = []


def generateAllPartitions(possibleRoute: List[int], minimum: int, numberOfVehicles: int) -> List[List[List[int]]]:
    """
    Recursively generates all possible partitions for a given list with dimension N
    This allows us to determine every possible combination of routes for N vehicles
    :param possibleRoute: A list containing each node which must be visited before returning to the starting node
    :param minimum: Used in our recursive function to generate increasingly smaller subsets
    :param numberOfVehicles: The maximum length each partition should have.
    :return: Every partition of the provided list with dimension = numberOfVehicles. For example for N = 2:
    [1, 2, 3] -> [[1], [2, 3]]  ,  [[1, 2], [3]]  ,  [[1, 3], 2]
    Although [1, 2, 3] and [[1], [2], [3]] are valid partitions, they don't have dimension 2 so won't be returned
    """
    # Base Case
    if len(possibleRoute) == 1:
        yield [possibleRoute]
        return

    # Recursive Step
    first = possibleRoute[0]
    for smaller in generateAllPartitions(possibleRoute[1:], minimum - 1, numberOfVehicles):
        if len(smaller) > numberOfVehicles:
            continue
        # Insert `first` into each of the subpartition's subsets
        if len(smaller) >= minimum:
            for n, subset in enumerate(smaller):
                yield smaller[:n] + [[first] + subset] + smaller[n + 1:]
        # Put `first` into its own subset
        if len(smaller) < numberOfVehicles:
            yield [[first]] + smaller


def allRoutes(route: List[int]) -> List[List[int]]:
    """
    Generates all permutations of each subpartition, then appends the starting node to the start and end
    :param route: The subpartition
    :return: List of permutations with the starting and ending node appended
    """
    return [[route[0]] + list(rest) + [route[0]] for rest in itertools.permutations(route[1:])]


def determineRoutesFromPartitions(partitions: List[List[List[int]]], startingNode: int) -> List[List[List[int]]]:
    """
    Returns the route permutation which has the minimum length from each partition
    :param partitions: List of partitions generated by generateAllPartitions function
    :param startingNode: The node at which all vehicles will start and end on
    :return: The route permutation which has the minimum length
    """
    for partition in partitions:
        yield [min(allRoutes([startingNode] + subPartition), key=routeLength) for subPartition in partition]


def routeLength(route: List[int]) -> int:
    """
    Calculates the length of a given route
    :param route: The route which will be traversed
    :return: The length of the route
    """
    return sum(distance(route[i], route[i + 1]) for i in range(len(route) - 1))


def distance(x: int, y: int) -> int:
    """
    Returns the distance between node x and node y
    :param x: The node we are coming from
    :param y: The node we are going to
    :return: The distance between them
    """
    return distances[x][y]


def findShortestRoute(routes: List[List[List[int]]]) -> Tuple[List[List[int]], int]:
    """
    From our list of possible routes, find the route which minimises the length of the longest single route
    among all vehicles
    :param routes: The list of routes which we should consider in our brute force.
    :return: The route which has minimises the length of the longest single route among all vehicles, and its distance
    """
    shortestPath = []
    shortestPathLength = math.inf

    for route in routes:
        maxDistanceTravelled = max(routeLength(vehicle) for vehicle in route)
        if maxDistanceTravelled < shortestPathLength:
            shortestPathLength = maxDistanceTravelled
            shortestPath = route

    return shortestPath, shortestPathLength


def runBruteForceVRP(graph: Graph, startingNode: int = 0, numberOfVehicles: int = 3) -> Tuple[List[List[int]], int]:
    """
    Runs the brute force VRP algorithm on our graph
    :param graph: Uses our custom Graph class which contains the adjacency matrix
    :param startingNode: The node at which all vehicles will start and end on
    :param numberOfVehicles: The number of vehicles which will be traversing the graph
    :return: A tuple containing the minimum paths and the combined length of these paths
    """
    global distances
    distances = graph.adjMatrix

    nodesToVisit = [int(x) for x in range(graph.size) if x != startingNode]

    # Can't have more vehicles than visitable nodes.
    numberOfVehicles = min(numberOfVehicles, len(nodesToVisit))

    partitions = generateAllPartitions(nodesToVisit, numberOfVehicles, numberOfVehicles)
    routes = determineRoutesFromPartitions(partitions, startingNode)
    return findShortestRoute(routes)
